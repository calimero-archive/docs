---
title: Prover Contract
sidebar_position: 4
---

The Prover contract provides the ability to prove that an event occurred on a specific chain. It takes proof data as input, including a merkle path to the block where the transaction or receipt originated and a merkle path to the transaction or receipt itself. Additionally, the Prover requires the height of the known block in the light client contract, which should be ahead of or at the same block as the transaction being proven. By utilizing this information, the Prover can calculate the expected block merkle root and compare it to the one stored in the light client block.

## Proof Retrieval
To obtain proof for a specific receipt, an RPC call (EXPERIMENTAL_light_client_proof) can be made to the Archival node. This call, along with the block height from the light client contract (higher than the receipt's block height), provides all the necessary information required by the Prover.

The Prover contract utilizes the following data structures:



```rust
pub struct FullOutcomeProof {
    /// Proof of execution outcome
    pub outcome_proof: ExecutionOutcomeWithIdAndProof,
    /// Proof of shard execution outcome root
    pub outcome_root_proof: MerklePath,
    /// A light weight representation of block that contains the outcome root
    pub block_header_lite: BlockHeaderLight,
    /// Proof of the existence of the block in the block merkle tree,
    /// which consists of blocks up to the light client head
    pub block_proof: MerklePath,
}
```

```rust
pub struct BlockHeaderLight {
    pub prev_block_hash: Hash,
    pub inner_rest_hash: Hash,
    pub inner_lite: BlockHeaderInnerLite,
}
```


```rust 
pub struct ExecutionOutcomeWithIdAndProof {
    /// Proof of the execution outcome
    pub proof: MerklePath,
    /// Block hash of the block that contains the outcome root
    pub block_hash: Hash,
    pub outcome_with_id: ExecutionOutcomeWithId,
}
```

```rust
pub struct ExecutionOutcomeWithId {
    /// The transaction hash or the receipt ID.
    pub id: Hash,
    /// The actual outcome
    pub outcome: ExecutionOutcome,
}
```

```rust
pub struct ExecutionOutcome {
    /// Logs from this transaction or receipt.
    pub logs: Vec<Vec<u8>>,
    /// Receipt IDs generated by this transaction or receipt.
    pub receipt_ids: Vec<Hash>,
    /// The amount of the gas burnt by the given transaction or receipt. 
    pub gas_burnt: u64,     
    /// The total number of the tokens burnt by the given transaction or receipt.
    pub tokens_burnt: u128, 
    /// The transaction or receipt id that produced this outcome.
    pub executor_id: String, 
    /// Execution status. Contains the result in case of successful execution.
    pub status: ExecutionStatus, 
}
```

## Verifying the Proof

The verification of the proof involves two steps:

### Execution Outcome Root Verification
If the outcome root of the transaction or receipt is included in block `B`, the `outcome_proof` contains the block hash of `B` and the merkle proof of the execution outcome within its shard. The outcome root in `B` can be reconstructed using the following process:

```rust
shard_outcome_root = compute_root(sha256(execution_outcome.hash()), outcome_proof.proof);
block_outcome_root = compute_root(sha256(shard_outcome_root.hash()), outcome_root_proof);
```

It is crucial that this outcome root matches the outcome root in `block_header_lite.inner_lite`.

### Block Merkle Root Verification

The block hash can be computed from `BlockHeaderLight` using the following function:

```rust
fn compute_block_hash(block_header_lite: &BlockHeaderLight) -> Hash {
    sha256(concat(
        sha256(concat(
            sha256(block_header_lite.inner_lite.hash()),
            sha256(block_header_lite.inner_rest_hash)
        )),
        block_header_lite.prev_hash
    ))
}
```

The expected block merkle root can be calculated as follows:

```rust
block_hash = compute_block_hash(block_header_lite);
block_merkle_root = compute_root(block_hash, block_proof);
```
This computed block merkle root must match the block merkle root stored in the light client block of the light client head.

To calculate the root, the following function is used:


```rust
fn compute_root(node: &Hash, path: MerklePath) -> Hash {
    let mut hash: Hash = *node;
    for item in path.items {
        hash = match item.direction {
            MERKLE_PATH_LEFT => sha256(concat(item.hash(), hash)),
            MERKLE_PATH_RIGHT => sha256(concat(hash, item.hash())),
        }
        .try_into()
        .unwrap()
    }
    return hash;
}
```